
<!--
help_text: ''
key: summary_monitoring_&_reporting_d847a4d4-88d1-4ea3-a899-31820967f2f0
modules:
- flytekit.deck.deck
- flytekit.deck.renderer
- flytekit.remote.metrics
- flytekit.core.base_task
- flytekit.core.context_manager
- flytekitplugins.deck.renderer
questions_to_answer: []
type: summary

-->
# Monitoring & Reporting

Monitoring and reporting in Flyte provide comprehensive insights into task execution, enabling developers to visualize data, track performance, and understand the operational context of their workflows. This functionality is primarily delivered through **Flyte Decks** for in-task visualizations and **Execution Spans** for detailed performance analysis.

## Flyte Decks: In-Task Visualizations

Flyte Decks offer a powerful way to embed rich, customizable HTML reports directly within your task executions. These reports provide immediate visibility into task inputs, outputs, internal states, and environmental details, enhancing debugging and understanding of complex data pipelines.

### Core Concepts

A Deck is a container for HTML content generated by various renderers. When a task executes, the content from its associated Decks is compiled into an HTML file, which can then be viewed in the Flyte UI.

Tasks automatically include several default Decks:
*   **Input Deck:** Renders the task's input data.
*   **Output Deck:** Renders the task's output data.
*   **Default Deck:** A general-purpose Deck for custom visualizations, plots, or markdown.

Developers can also create additional custom Decks to organize specific types of information.

### Enabling and Configuring Decks

Deck generation is controlled at the task level using parameters available in the `PythonTask` class.

To enable decks for a task, set the `enable_deck` parameter to `True`:

```python
from flytekit import task

@task(enable_deck=True)
def my_task(x: int) -> int:
    # ... task logic ...
    return x
```

You can specify which standard fields should be included in the generated decks using the `deck_fields` parameter. This parameter accepts a tuple of `DeckField` enum members.

The available `DeckField` members are:
*   `DeckField.INPUT`: Renders task input data.
*   `DeckField.OUTPUT`: Renders task output data.
*   `DeckField.SOURCE_CODE`: Renders the task's Python source code.
*   `DeckField.TIMELINE`: Renders a timeline of task execution components.
*   `DeckField.DEPENDENCIES`: Renders a list of installed Python dependencies.

For example, to enable decks for input, output, and source code:

```python
from flytekit import task
from flytekit.deck import DeckField

@task(enable_deck=True, deck_fields=(DeckField.INPUT, DeckField.OUTPUT, DeckField.SOURCE_CODE))
def my_data_processing_task(df: pd.DataFrame) -> pd.DataFrame:
    # ...
    return df
```

### Creating Custom Decks

Beyond the default decks, you can create new `Deck` instances and append HTML content to them. These custom decks will be published alongside the default ones.

```python
from flytekit import Deck, current_context, task
from flytekit.deck.renderer import MarkdownRenderer
import pandas as pd

@task(enable_deck=True)
def analyze_data(df: pd.DataFrame) -> str:
    # Create a custom Deck
    my_custom_deck = Deck("Data Summary")
    
    # Append markdown content
    md_renderer = MarkdownRenderer()
    summary_text = f"## Data Analysis Report\n\nDataset has {len(df)} rows and {len(df.columns)} columns."
    my_custom_deck.append(md_renderer.to_html(summary_text))
    
    # Append a table of descriptive statistics
    my_custom_deck.append(df.describe().to_html())

    # You can also append to the default deck
    default_deck = current_context().default_deck
    default_deck.append(md_renderer.to_html("### This is also in the default deck!"))

    return "Analysis complete."
```

The `Deck.publish()` method is responsible for writing the accumulated HTML content to a file. In most cases, this is automatically handled by the Flyte execution context at the end of a task's execution.

### Accessing Decks in Local Execution

During local execution, you can retrieve the generated deck content from the `FlyteContext` after a task run:

```python
from flytekit import new_context

with new_context() as ctx:
    result = analyze_data(pd.DataFrame({"col1": [1, 2, 3]}))
    html_output = ctx.get_deck()
    # html_output can be displayed in a Jupyter notebook or saved to a file
```

## Built-in Deck Renderers

Renderers are specialized classes that convert various Python objects into HTML strings, making them suitable for display within Decks. The `Renderable` protocol defines the `to_html` interface that all renderers implement.

### Data Visualization Renderers

*   **`TopFrameRenderer`**: Renders the head of a Pandas DataFrame as an HTML table. Useful for quickly inspecting data.
    ```python
    from flytekit.deck.renderer import TopFrameRenderer
    import pandas as pd
    from typing_extensions import Annotated

    @task
    def process_df() -> Annotated[pd.DataFrame, TopFrameRenderer(max_rows=5)]:
        df = pd.DataFrame({"A": range(10), "B": [x * 2 for x in range(10)]})
        return df
    ```
*   **`TableRenderer`**: Converts an entire Pandas DataFrame into a styled HTML table. Allows custom header labels and table width.
    ```python
    from flytekit.deck.renderer import TableRenderer
    
    deck = Deck("Full Table")
    df = pd.DataFrame({"Name": ["Alice", "Bob"], "Age": [30, 24]})
    deck.append(TableRenderer().to_html(df, header_labels=["Person Name", "Years Old"], table_width=400))
    ```
*   **`ArrowRenderer`**: Renders a PyArrow Table as a string representation.
*   **`BoxRenderer`**: Generates a Plotly box plot for a specified column in a Pandas DataFrame.
    ```python
    from flytekit.deck.renderer import BoxRenderer
    
    deck = Deck("Box Plot")
    df = pd.DataFrame({"value": [1, 2, 3, 4, 5, 10, 100]})
    deck.append(BoxRenderer("value").to_html(df))
    ```
*   **`FrameProfilingRenderer`**: Creates a detailed profiling report for a Pandas DataFrame using `ydata-profiling`.
    ```python
    from flytekit.deck.renderer import FrameProfilingRenderer
    
    deck = Deck("Profiling Report")
    df = pd.DataFrame({"A": [1, 2, 3], "B": ["x", "y", "z"]})
    deck.append(FrameProfilingRenderer(title="My Data Profile").to_html(df))
    ```
*   **`ImageRenderer`**: Converts a `FlyteFile` (image path) or a `PIL.Image.Image` object into an HTML `<img>` tag with base64-encoded image data.
    ```python
    from flytekit.deck.renderer import ImageRenderer
    from flytekit.types.file import FlyteFile
    from PIL import Image
    
    # Assuming 'my_image.png' is a FlyteFile or a local path
    image_file = FlyteFile("s3://my-bucket/my_image.png") 
    deck.append(ImageRenderer().to_html(image_file))
    
    # Or directly from a PIL Image object
    img = Image.new('RGB', (60, 30), color = 'red')
    deck.append(ImageRenderer().to_html(img))
    ```

### Code and Environment Renderers

*   **`SourceCodeRenderer`**: Highlights Python source code using Pygments for improved readability.
    ```python
    from flytekit.deck.renderer import SourceCodeRenderer
    
    code = "def hello():\n    print('Hello, Flyte!')"
    deck.append(SourceCodeRenderer().to_html(code))
    ```
    *Note: The `flytekitplugins.deck.renderer.SourceCodeRenderer` is deprecated. Use `flytekit.deck.renderer.SourceCodeRenderer` instead.*
*   **`PythonDependencyRenderer`**: Lists all Python packages installed in the execution environment, including a button to copy them as a `requirements.txt` file.
    ```python
    from flytekit.deck.renderer import PythonDependencyRenderer
    
    deck = Deck("Dependencies")
    deck.append(PythonDependencyRenderer().to_html())
    ```

### Text Renderers

*   **`MarkdownRenderer`**: Converts Markdown formatted strings into HTML.
    ```python
    from flytekit.deck.renderer import MarkdownRenderer
    
    markdown_text = "# My Report\n\nThis is a **bold** statement."
    deck.append(MarkdownRenderer().to_html(markdown_text))
    ```
    *Note: The `flytekitplugins.deck.renderer.MarkdownRenderer` is deprecated. Use `flytekit.deck.renderer.MarkdownRenderer` instead.*

## Timeline Monitoring with `TimeLineDeck`

The `TimeLineDeck` is a specialized Deck designed to visualize the execution duration of different components within a task. Unlike a standard `Deck`, it delays HTML generation until all time-related data is collected, ensuring a complete and meaningful visualization.

The `TimeLineDeck` uses the `GanttChartRenderer` internally to produce interactive Gantt charts from collected time information.

To access the timeline deck within a task:

```python
from flytekit import current_context
from flytekit.deck import DeckField

@task(enable_deck=True, deck_fields=(DeckField.TIMELINE,))
def my_timed_task():
    ctx = current_context()
    timeline_deck = ctx.user_space_params.timeline_deck
    
    # Simulate collecting time info (this is usually done automatically by Flytekit)
    timeline_deck.append_time_info({"Start": "...", "Finish": "...", "Name": "Step 1"})
    timeline_deck.append_time_info({"Start": "...", "Finish": "...", "Name": "Step 2"})
    
    # The HTML is generated when the 'html' property is accessed, typically at task completion.
```

**Important Considerations for Timeline Deck:**
*   Very short durations (less than 1ms) may be difficult to visualize accurately on the graph.
*   For precise execution time measurements, refer to wall time and process time metrics rather than relying solely on the visual timeline.

## Execution Spans for Performance Analysis

Beyond visual decks, Flyte provides `FlyteExecutionSpan` for deeper, programmatic analysis of execution performance. These spans represent hierarchical time-based data, capturing the duration of various operations within a Flyte execution.

The `FlyteExecutionSpan` class offers methods to inspect and dump this performance data:
*   **`explain()`**: Prints a human-readable, formatted summary of the execution span, showing operation names, start/end timestamps, duration, and associated entities. This is useful for quick console-based debugging.
*   **`dump()`**: Outputs the execution span data in YAML format, providing a structured representation suitable for further processing or storage.

While `FlyteExecutionSpan` is primarily an internal representation of execution metrics, its `explain` and `dump` methods allow developers to programmatically access and analyze the performance characteristics of their tasks and workflows, aiding in optimization and bottleneck identification.

## Key Considerations

*   **Performance Overhead:** Generating extensive decks, especially with large dataframes or complex profiling reports, can introduce overhead to task execution time and increase storage requirements for the generated HTML files. Use `deck_fields` judiciously to include only necessary information.
*   **Security and Data Sensitivity:** Be mindful of sensitive data or proprietary source code when enabling decks. The generated HTML files will contain the rendered information, which might be accessible to users with permissions to view task execution details.
*   **Local vs. Remote Behavior:** While decks can be generated and accessed locally for development and debugging, their primary utility is in the Flyte UI for remote executions. The `_output_deck` function handles the publishing mechanism differently based on the execution environment.
*   **Context Management:** Deck functionality relies on the `FlyteContext` and `ExecutionParameters` to manage the collection and publishing of HTML content. The `current_context()` function provides access to the `ExecutionParameters`, which in turn holds the list of `Deck` objects.
*   **Deprecation Warnings:** Pay attention to deprecation warnings for older renderer classes (`flytekitplugins.deck.renderer.MarkdownRenderer`, `flytekitplugins.deck.renderer.SourceCodeRenderer`) and the `disable_deck` parameter. Always use the recommended alternatives (`flytekit.deck.renderer.MarkdownRenderer`, `flytekit.deck.renderer.SourceCodeRenderer`, and `enable_deck`).
<!--
key: summary_monitoring_&_reporting_d847a4d4-88d1-4ea3-a899-31820967f2f0
type: summary_end

-->
<!--
code_unit: flytekit.deck.deck.Deck
code_unit_type: class
help_text: ''
key: example_26ff7dca-cb69-4a7b-85ff-497de3f956d7
type: example

-->
<!--
code_unit: flytekit.remote.metrics.FlyteExecutionSpan
code_unit_type: class
help_text: ''
key: example_441c5f68-7e40-47f7-93c9-7eb1e64c0c4b
type: example

-->