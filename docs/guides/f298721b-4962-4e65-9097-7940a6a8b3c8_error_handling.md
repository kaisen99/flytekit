
<!--
help_text: ''
key: summary_error_handling_8bf77e54-4919-4dc3-a5d6-7ef9772492c4
modules:
- flytekit.exceptions.base
- flytekit.exceptions.eager
- flytekit.exceptions.scopes
- flytekit.exceptions.system
- flytekit.exceptions.user
questions_to_answer: []
type: summary

-->
# Error Handling

Flyte provides a robust and structured approach to error handling, categorizing issues to provide clear insights into workflow execution failures. This system helps developers distinguish between problems originating from user code and those stemming from the underlying Flyte platform, and further classifies errors based on their recoverability.

## Core Exception Hierarchy

All Flyte-specific exceptions derive from the `FlyteException` class, located in the `flytekit.exceptions.base` namespace. This base class establishes a consistent structure for all errors within the Flyte ecosystem.

### `FlyteException`: The Foundation

The `FlyteException` class serves as the root for all custom Flyte errors. It includes:

*   **`_ERROR_CODE`**: A static string attribute that provides a unique identifier for the exception type. This code is automatically included in the exception's string representation, aiding in quick identification of the error source.
*   **`timestamp`**: An optional floating-point value representing the time the exception was raised, in fractional seconds since the epoch. This can be useful for debugging and logging.

When an `FlyteException` or any of its derivatives is converted to a string, it automatically formats the output to include its `_ERROR_CODE` and the provided error message.

### Error Categorization: User vs. System

Flyte categorizes exceptions into two primary types:

*   **User Exceptions**: These errors originate from issues within the user's code, such as incorrect input types, invalid values, or logical errors. They are derived from `FlyteUserException` (in `flytekit.exceptions.user`).
*   **System Exceptions**: These errors indicate problems with the Flyte platform itself, its infrastructure, or internal components. They are derived from `FlyteSystemException` (in `flytekit.exceptions.system`).

This distinction is crucial for debugging and for determining who is responsible for resolving the issue.

### Recoverability

Flyte further classifies errors based on whether they are `Recoverable` or `Non-Recoverable`. This classification directly influences how Flyte's execution engine handles retries:

*   **Recoverable Exceptions**: These indicate transient issues that might resolve themselves upon retry, such as temporary network outages or resource contention. Exceptions inheriting from `FlyteRecoverableException` (in `flytekit.exceptions.base` for general recoverability, or `flytekit.exceptions.user` for user-specific recoverable errors) signal to the Flyte engine that a retry might succeed.
*   **Non-Recoverable Exceptions**: These indicate persistent issues that are unlikely to be resolved by a simple retry, such as programming errors, invalid configurations, or missing data. `FlyteNonRecoverableSystemException` explicitly marks a system error as non-recoverable. Most `FlyteUserException` types are implicitly non-recoverable unless they explicitly inherit from `FlyteRecoverableException`.

## Handling User-Generated Errors

User-generated errors are typically caught and wrapped by Flyte to provide a consistent error reporting mechanism.

### Common User Exceptions

The `flytekit.exceptions.user` namespace provides a comprehensive set of exceptions for common user-related issues:

*   **`FlyteTypeException`**: Raised when a function receives an argument of an unexpected type. This is particularly useful for validating inputs to tasks and workflows.
    ```python
    from flytekit.exceptions.user import FlyteTypeException

    def process_data(data: int):
        if not isinstance(data, int):
            raise FlyteTypeException(type(data), int, received_value=data)
        return data * 2
    ```
*   **`FlyteValueException`**: Raised when an argument's value is invalid, even if its type is correct. `FlyteDataNotFoundException` is a specialized version for missing data.
    ```python
    from flytekit.exceptions.user import FlyteValueException

    def validate_positive(value: int):
        if value <= 0:
            raise FlyteValueException(value, "Value must be positive.")
        return value
    ```
*   **`FlyteCompilationException`**: A base class for errors detected during the compilation phase of Flyte entities (tasks, workflows).
    *   **`FlyteMissingTypeException`**: Indicates a missing type annotation for a parameter.
    *   **`FlyteMissingReturnValueException`**: Indicates a function that should return a value but does not.
*   **`FlyteAssertion`**: A general assertion failure within user code, similar to Python's built-in `AssertionError`.
*   **`FlyteInvalidInputException`**: Raised when an API request has invalid input.
*   **`FlyteEntityNotFoundException`**: Indicates that a specified task or workflow could not be found.
*   **`FlyteUserRuntimeException`**: This exception is crucial for wrapping arbitrary exceptions raised within user code. When a standard Python exception (e.g., `ValueError`, `KeyError`) occurs inside a Flyte task or workflow, it is often wrapped by `FlyteUserRuntimeException` before being propagated. This ensures that the original exception's details are preserved while conforming to Flyte's exception hierarchy.

    ```python
    from flytekit import task
    from flytekit.exceptions.user import FlyteUserRuntimeException

    @task
    def my_task(x: int) -> int:
        if x < 0:
            raise ValueError("Input must be non-negative") # This will be wrapped
        return x + 1

    # When my_task(-1) is executed, the ValueError will be caught and re-raised
    # as a FlyteUserRuntimeException by the Flyte runtime.
    ```

## Handling System-Level Errors

System exceptions indicate problems with the Flyte platform itself. While users typically cannot directly resolve these, understanding them helps in reporting issues to platform administrators.

The `flytekit.exceptions.system` namespace contains these exceptions:

*   **`FlyteSystemException`**: The base class for all system-level errors.
*   **`FlyteEntrypointNotLoadable`**: Raised when Flyte cannot load the Python module or find the task/workflow entrypoint. This often indicates issues with the user's code structure, dependencies, or environment.
*   **`FlyteDownloadDataException` / `FlyteUploadDataException`**: Indicate failures during data transfer operations to or from the Flyte data plane.
*   **`FlyteSystemUnavailableException`**: Signifies that the Flyte cluster or a critical service is unreachable.
*   **`FlyteNonRecoverableSystemException`**: Used to explicitly mark a system error as non-recoverable, preventing retries.
*   **`FlyteNotImplementedException`**: Indicates that a requested feature or functionality is not yet implemented.
*   **`FlyteSystemAssertion`**: A system-level assertion failure.

## Eager Workflow Error Handling

For workflows defined using the `eager` decorator, the `EagerException` (from `flytekit.exceptions.eager`) provides a specific mechanism for catching and handling errors that occur within the workflow's execution graph.

When a task or subworkflow within an `eager` workflow raises an exception, it is caught and re-raised as an `EagerException`. This allows the `eager` workflow function to use standard Python `try...except` blocks to manage failures from its constituent nodes.

```python
from flytekit import task, eager
from flytekit.exceptions.eager import EagerException

@task
def add_one(x: int) -> int:
    if x < 0:
        raise ValueError("x must be positive")
    return x + 1

@task
def double(x: int) -> int:
    return x * 2

@eager
async def eager_workflow(x: int) -> int:
    try:
        out = await add_one(x=x)
    except EagerException as e:
        # The ValueError from add_one is caught as an EagerException.
        # The original exception can be accessed via e.__cause__ if needed.
        print(f"Caught an eager exception: {e}")
        raise # Re-raise to propagate the failure
    return await double(x=out)

# Example usage:
# await eager_workflow(-5) will raise an EagerException
# await eager_workflow(10) will complete successfully
```

## Deprecated Scoped Exceptions

The `flytekit.exceptions.scopes` package, including `FlyteScopedException`, `FlyteScopedUserException`, and `FlyteScopedSystemException`, is deprecated. While these classes historically provided detailed traceback trimming and context, their functionality is being superseded by the more streamlined `FlyteException` hierarchy and improved runtime error reporting. Developers should avoid using these deprecated classes in new code.

## Best Practices for Error Handling

*   **Raise Specific Exceptions**: When writing Flyte tasks or workflows, raise the most specific `FlyteUserException` possible (e.g., `FlyteTypeException`, `FlyteValueException`) to provide clear error messages and codes.
*   **Wrap External Exceptions**: If your code interacts with external libraries or APIs that raise standard Python exceptions, consider wrapping them in a `FlyteUserRuntimeException` if you need to propagate them within the Flyte context, especially if you want to add Flyte-specific metadata or ensure consistent error codes.
*   **Leverage Recoverability**: Design your tasks to raise `FlyteRecoverableException` for transient issues that can benefit from retries. For permanent issues, ensure a non-recoverable exception is raised.
*   **Monitor Error Codes**: Utilize the `_ERROR_CODE` attribute of `FlyteException` and its derivatives for programmatic error identification and monitoring in your operational dashboards.
*   **Handle Eager Workflow Errors**: When using `eager` workflows, explicitly use `try...except EagerException` blocks to manage failures from nested tasks and subworkflows, allowing for custom recovery logic or graceful degradation.
<!--
key: summary_error_handling_8bf77e54-4919-4dc3-a5d6-7ef9772492c4
type: summary_end

-->
<!--
code_unit: flytekit.exceptions.user
code_unit_type: class
help_text: ''
key: example_d3cbf2ec-c16e-449b-96b7-b22126836ac7
type: example

-->
<!--
code_unit: flytekit.exceptions.system
code_unit_type: class
help_text: ''
key: example_efe80a9e-94d3-4a6e-9447-cd2445428896
type: example

-->