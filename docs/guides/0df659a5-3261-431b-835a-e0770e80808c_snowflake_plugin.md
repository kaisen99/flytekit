
<!--
help_text: ''
key: summary_snowflake_plugin_fd166932-997a-4cd1-9de0-fcf29e1e4c0a
modules:
- flytekitplugins.snowflake.connector
- flytekitplugins.snowflake.task
questions_to_answer: []
type: summary

-->
The Snowflake Plugin enables users to execute SQL queries on Snowflake databases directly as Flyte tasks. This integration allows for seamless orchestration of data transformations and analytical workloads within Flyte workflows, leveraging Snowflake's powerful data warehousing capabilities.

### Defining Snowflake Tasks

Snowflake tasks are defined using the `SnowflakeTask` class. This class extends Flyte's `SQLTask` and `AsyncConnectorExecutorMixin`, indicating its capability to run SQL queries asynchronously and manage their lifecycle.

To define a Snowflake task, specify the following:

*   **`name`**: A unique name for the task within your Flyte project.
*   **`query_template`**: The SQL query to be executed. This template supports Flyte's Golang templating syntax, allowing for dynamic injection of input parameters.
*   **`task_config`**: An instance of `SnowflakeConfig` that provides the necessary connection details to your Snowflake instance.
*   **`inputs` (Optional)**: A dictionary mapping input variable names to their Flyte types. These inputs are passed to the `query_template`.
*   **`output_schema_type` (Optional)**: If your query produces a result set, specify the type as `StructuredDataset`. This allows Flyte to capture and manage the query output.

**Example:**

```python
from flytekitplugins.snowflake.task import SnowflakeTask, SnowflakeConfig
from flytekit.types.structured.structured_dataset import StructuredDataset
from typing import Type

# Define your Snowflake configuration
snowflake_config = SnowflakeConfig(
    user="your_user",
    account="your_account",
    database="your_database",
    schema="your_schema",
    warehouse="your_warehouse",
)

# Define a Snowflake task that takes an input and produces an output
snowflake_query_task = SnowflakeTask(
    name="my_snowflake_query_task",
    query_template="SELECT * FROM my_table WHERE id = {{ .inputs.id }};",
    task_config=snowflake_config,
    inputs={"id": int},
    output_schema_type=Type[StructuredDataset],
)

# Define a Snowflake task that does not produce an output (e.g., DDL/DML)
snowflake_dml_task = SnowflakeTask(
    name="my_snowflake_dml_task",
    query_template="INSERT INTO my_table (col1, col2) VALUES ('value1', 'value2');",
    task_config=snowflake_config,
)
```

### Snowflake Configuration

The `SnowflakeConfig` class encapsulates the connection parameters required to connect to your Snowflake instance.

```python
from flytekitplugins.snowflake.task import SnowflakeConfig

config = SnowflakeConfig(
    user="your_user",
    account="your_account",
    database="your_database",
    schema="your_schema",
    warehouse="your_warehouse",
)
```

You can retrieve these configuration details from your Snowflake environment using the following SQL query:

```sql
SELECT
    CURRENT_USER() AS "User",
    CONCAT(CURRENT_ORGANIZATION_NAME(), '-', CURRENT_ACCOUNT_NAME()) AS "Account",
    CURRENT_DATABASE() AS "Database",
    CURRENT_SCHEMA() AS "Schema",
    CURRENT_WAREHOUSE() AS "Warehouse";
```

### Handling Query Inputs and Outputs

#### Query Inputs

Inputs defined in the `inputs` parameter of `SnowflakeTask` are automatically made available to the `query_template` using Flyte's Golang templating syntax. For example, an input named `id` can be referenced as `{{ .inputs.id }}` within the SQL statement. This allows for dynamic and parameterized queries, enhancing reusability and security by preventing SQL injection.

#### Query Outputs

When a Snowflake query is expected to return a result set, specify `output_schema_type=Type[StructuredDataset]` in the `SnowflakeTask` definition. Flyte represents the output of the Snowflake query as a `StructuredDataset`.

The `SnowflakeConnector` internally constructs a URI for the `StructuredDataset` that points to the executed query's results within Snowflake. This URI follows the format:
`snowflake://<user>:<account>/<warehouse>/<database>/<schema>/<query_id>`

This URI allows downstream tasks to access the query results directly from Snowflake.

### Asynchronous Execution and Job Management

Snowflake tasks execute asynchronously. When a `SnowflakeTask` is launched, the `SnowflakeConnector` submits the query to Snowflake and immediately returns a `SnowflakeJobMetadata` object containing the `query_id`. Flyte then periodically polls Snowflake using this `query_id` to check the query's status.

The `SnowflakeConnector` handles the full lifecycle of the Snowflake query:

*   **`create`**: Submits the SQL query to Snowflake using `execute_async` and returns `SnowflakeJobMetadata` with the `query_id`.
*   **`get`**: Polls the status of the query using `get_query_status_throw_if_error`. It converts Snowflake's query status into Flyte's `TaskExecution.Phase`. If the query succeeds and `has_output` is true, it constructs a `StructuredDataset` pointing to the results. A `TaskLog` link to the Snowflake UI for the specific query is also provided, enabling easy debugging and monitoring.
*   **`delete`**: Cancels the running Snowflake query using `SYSTEM$CANCEL_QUERY`.

This asynchronous model ensures that Flyte workflows do not block while waiting for long-running Snowflake queries to complete, optimizing resource utilization.

### Authentication and Security Considerations

The `SnowflakeConnector` uses a private key for authentication (`private_key=get_private_key()`). The `get_private_key()` function is an internal mechanism that retrieves the private key. It is crucial to manage this private key securely, typically through environment variables, secrets management systems, or Flyte's secret management capabilities, rather than hardcoding it.

### Best Practices

*   **Parameterize Queries**: Always use Flyte inputs and Golang templating for dynamic values in your SQL queries. This improves security, reusability, and readability.
*   **Define Output Schemas**: For queries that produce data, explicitly define `output_schema_type=Type[StructuredDataset]`. This enables Flyte's type system to track data lineage and facilitates seamless data passing to subsequent tasks.
*   **Secure Credentials**: Ensure that Snowflake connection details, especially private keys, are managed securely and are not exposed in plain text within your code or configuration files. Leverage Flyte's built-in secret management features.
*   **Monitor Query Performance**: Utilize the provided `TaskLog` link to the Snowflake UI to monitor query execution, identify bottlenecks, and optimize performance.
<!--
key: summary_snowflake_plugin_fd166932-997a-4cd1-9de0-fcf29e1e4c0a
type: summary_end

-->
<!--
code_unit: flytekitplugins.snowflake.task
code_unit_type: class
help_text: ''
key: example_345a502d-8b70-42bb-a551-7565d2d6b133
type: example

-->