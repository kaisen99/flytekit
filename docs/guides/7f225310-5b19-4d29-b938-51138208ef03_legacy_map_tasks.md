
<!--
help_text: ''
key: summary_legacy_map_tasks_d7ecfadd-c6f3-4d23-8a03-c468e354fde9
modules:
- flytekit.core.legacy_map_task
questions_to_answer: []
type: summary

-->
Legacy Map Tasks enable the parallel execution of a single Python function or instance method across a collection of inputs. This capability is fundamental for processing large datasets or performing batch operations efficiently within a workflow.

## Core Components

Legacy Map Tasks are primarily implemented through two core components: the `MapPythonTask` and the `MapTaskResolver`.

### MapPythonTask

The `MapPythonTask` defines how an inner Python function or instance method runs in parallel over a range of inputs. It wraps an existing task, transforming its interface to accept collections of inputs and produce collections of outputs.

**Key Characteristics:**

*   **Task Composition:** A `MapPythonTask` encapsulates an underlying `PythonFunctionTask` or `PythonInstanceTask`. This inner task defines the logic executed for each item in the input collection.
*   **Interface Transformation:** The `MapPythonTask` automatically converts the inner task's scalar input types into list types (e.g., `int` becomes `List[int]`). Similarly, if the inner task produces a single output, the `MapPythonTask` produces a list of that output type.
*   **Bound Inputs:** It supports scenarios where some inputs to the inner task are fixed using `functools.partial`. These "bound inputs" are not mapped over; instead, they are passed as scalar values to each parallel instance of the inner task. The `MapPythonTask` automatically deduces these bound inputs from `partial.keywords` if a `partial` function is provided.
*   **Configuration:**
    *   `concurrency`: Limits the number of parallel sub-tasks that can run simultaneously.
    *   `min_success_ratio`: Specifies the minimum fraction of successful sub-tasks required for the overall map task to be considered successful. If the number of successful sub-tasks falls below this ratio, the map task fails.

**Example:**

Consider an inner task `process_item(item: int, config: str) -> str`. A `MapPythonTask` wrapping this would expose an interface like `(item: List[int], config: str) -> List[str]` if `config` is a bound input, or `(item: List[int], config: List[str]) -> List[str]` if both are mapped.

### MapTaskResolver

The `MapTaskResolver` is a specialized resolver responsible for handling the serialization and deserialization of `MapPythonTask`s. Its primary role is to reconstruct the `MapPythonTask`'s interface and configuration, especially when `functools.partial` is used to bind inputs.

When a `MapPythonTask` is serialized, the `MapTaskResolver` records the names of the bound input variables and the location of the underlying task's resolver. During deserialization, it uses this information to correctly load the `MapPythonTask` and its inner task, ensuring that the interface accurately reflects which inputs are mapped and which are fixed.

## Capabilities and Usage

Legacy Map Tasks provide robust capabilities for parallel processing:

*   **Parallel Execution:** The core capability is to execute a single task logic across multiple data points concurrently. This is achieved by transforming the inner task into an array job, where each element of the input collection corresponds to an individual job instance.
*   **Handling Partial Functions:** Developers can use `functools.partial` to pre-fill certain arguments of the inner task. This allows for flexible mapping where only a subset of the inner task's inputs are iterated over. For example, if a function `process_data(data: str, mode: str)` is mapped, `map_task(functools.partial(process_data, mode="fast"))` will map only over the `data` input, while `mode` remains constant for all parallel executions.
*   **Fault Tolerance:** The `min_success_ratio` parameter enables a degree of fault tolerance. If a few individual sub-tasks fail, the overall map task can still succeed as long as the success ratio threshold is met. The outputs for failed sub-tasks will be `None` if `min_success_ratio` is less than 1.0.
*   **Dynamic Command Generation:** The `MapPythonTask` dynamically generates the command for its container, embedding the `MapTaskResolver`'s details and the underlying task's loader arguments. This ensures that the Flyte platform can correctly execute individual instances of the mapped task.

## Execution Modes

Legacy Map Tasks behave differently depending on the execution environment:

*   **Local Execution:** When executed locally (e.g., during development or testing), the `MapPythonTask`'s `_raw_execute` method iterates through the input collections and sequentially calls the inner task for each item. It collects all outputs into a list, mimicking the parallel behavior. This mode also enforces the `min_success_ratio` locally.
*   **Platform Execution:** On the Flyte platform, a `MapPythonTask` is translated into a `CONTAINER_ARRAY_TASK`. Each instance of the array job (corresponding to an element in the input collection) executes the inner task using the `_execute_map_task` method. This method retrieves the specific input for the current array job index from the provided input lists and passes it to the inner task. The Flyte array plugin handler then aggregates the individual outputs from each array job instance into a single collection for the overall map task output.

## Important Considerations

*   **Inner Task Constraints:** The inner task wrapped by a `MapPythonTask` must be either a `PythonFunctionTask` or a `PythonInstanceTask`. It must also have zero or one output. Tasks with multiple outputs are not supported for mapping.
*   **Partial Input Limitations:** When using `functools.partial`, the bound inputs (those specified in `partial.keywords`) cannot be lists. They must be scalar values.
*   **Performance:** The `concurrency` setting directly impacts resource utilization and overall execution time. Higher concurrency can lead to faster completion but requires more resources.
*   **Output Handling:** When `min_success_ratio` is set to less than 1.0, the output list may contain `None` values for sub-tasks that failed but did not cause the overall map task to fail. Consumers of the map task's output should account for these potential `None` values.
*   **"Legacy" Naming:** While fully functional and supported, the "legacy" designation in the name suggests it might be an older implementation pattern. Developers should be aware of this context, though the current documentation does not indicate a direct replacement or deprecation.
<!--
key: summary_legacy_map_tasks_d7ecfadd-c6f3-4d23-8a03-c468e354fde9
type: summary_end

-->
<!--
code_unit: flytekit.core.legacy_map_task.MapPythonTask
code_unit_type: class
help_text: ''
key: example_cb0dce79-4477-42b4-9e0b-37f552e34e55
type: example

-->