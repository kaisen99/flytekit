
<!--
help_text: ''
key: summary_execution_context_&_state_management_84e7bac5-8317-4448-8e33-ae4ea57be726
modules:
- flytekit.core.context_manager.ExecutionParameters
- flytekit.core.context_manager.FlyteContext
- flytekit.core.context_manager.ExecutionState
questions_to_answer: []
type: summary

-->
Execution Context & State Management

Execution context and state management are fundamental to how tasks and workflows operate, providing the necessary environment and data for execution. This system distinguishes between a user-facing context, which provides runtime parameters for task logic, and an internal context, which manages the underlying execution and compilation states.

## User-Facing Execution Context

The `ExecutionParameters` object provides a user-centric runtime context accessible within every `@task` method. This object is designed to give developers access to essential information and utilities relevant to the current execution without exposing internal system details.

Access the current execution parameters using the `current_context()` function:

```python
from flytekit import current_context

def my_task_function():
    ctx = current_context()
    # Use ctx properties
```

### Key Capabilities

The `ExecutionParameters` object offers the following capabilities:

*   **Metrics and Logging:**
    *   `stats`: A handle to a specialized statsd object for emitting tagged metrics. Use this for performance monitoring and operational insights.
    *   `logging`: A handle to a configured logging object. Use this for structured logging within your task.
*   **Execution Identifiers:**
    *   `execution_id`: The unique identifier for the workflow execution within the underlying engine. This ID remains consistent across all tasks within a workflow or sub-workflow.
    *   `task_id`: The identifier for the current task execution. This is generated by the backend at runtime.
    *   `execution_date`: The datetime when the workflow execution started. This is consistent across all tasks in a workflow.
    *   **Important:** Do not use `execution_id` or `execution_date` to drive production logic. They are primarily useful as tags for output data to link back to the originating workflow run for debugging and traceability.
*   **File System Access:**
    *   `working_directory`: A dedicated temporary directory for the task to write arbitrary files. This is useful for intermediate data storage.
    *   `raw_output_prefix`: The base path for raw output data.
    *   `output_metadata_prefix`: The base path for output metadata.
*   **State Management:**
    *   `checkpoint`: A handle to the configured checkpointing system, enabling state persistence across task retries or restarts.
*   **Secrets Management:**
    *   `secrets`: Provides access to a `SecretsManager` instance for securely retrieving sensitive information.
*   **Rich Output Generation (Decks):**
    *   `decks`: A list of `Deck` objects that can be used to generate rich HTML outputs (e.g., plots, tables, markdown) at the end of task execution.
    *   `default_deck`: A convenience property to access the default deck.
    *   `timeline_deck`: A specialized deck for visualizing execution timelines.
    *   `enable_deck`: Indicates whether deck generation is enabled for the current execution.
*   **Task-Specific Context:**
    *   The `ExecutionParameters` object can house additional task-specific context, such as a SparkSession for Spark tasks. Access these dynamic attributes using `get(key)` or direct attribute access (e.g., `ctx.SPARK_SESSION`). Use `has_attr(key)` to check for existence.

### Building and Modifying Execution Parameters

The `ExecutionParameters` object is immutable once created. To modify or extend its properties, use its `Builder` class. This pattern allows for creating new `ExecutionParameters` instances based on existing ones, ensuring a consistent and predictable context.

*   `new_builder(current: Optional[ExecutionParameters] = None)`: Creates a new builder, optionally initialized with an existing `ExecutionParameters` instance.
*   `builder()`: Returns a builder initialized with the current `ExecutionParameters` instance.
*   `with_task_sandbox()`: Creates a new builder with a task-specific sandbox directory and a corresponding checkpoint. This is useful for isolating task-level temporary files and checkpoints.
*   `with_enable_deck(enable_deck: bool)`: Creates a new builder with the deck feature enabled or disabled.
*   `add_attr(key: str, v: typing.Any)`: Adds custom attributes to the context.

**Example: Using `ExecutionParameters`**

```python
from flytekit import task, current_context
import logging

@task
def process_data(input_data: str) -> str:
    ctx = current_context()

    # Use the logging handler
    ctx.logging.info(f"Processing data for execution ID: {ctx.execution_id.name}")

    # Write a temporary file to the working directory
    temp_file_path = ctx.working_directory + "/temp_output.txt"
    with open(temp_file_path, "w") as f:
        f.write(f"Processed: {input_data}")
    ctx.logging.info(f"Wrote temp file to: {temp_file_path}")

    # Add content to the default deck
    ctx.default_deck.append(f"## Data Processed\nProcessed input: `{input_data}`")

    # Access task-specific context (if available, e.g., for a Spark task)
    if ctx.has_attr("SPARK_SESSION"):
        spark = ctx.get("SPARK_SESSION")
        ctx.logging.info(f"Spark session available: {spark}")

    return f"Processed {input_data} successfully!"
```

## Internal Context Management

The `FlyteContext` object is an internal-facing context that manages the overall state of the Flytekit library. It handles aspects like type conversion, workflow compilation, entity serialization, and interaction with the Flyte backend. Most users do not need to interact with `FlyteContext` directly.

The `FlyteContext` maintains several key states:

*   `file_access`: Manages file system operations, including local and remote storage.
*   `compilation_state`: Captures the state during the compilation of workflows and tasks into Flyte entities.
*   `execution_state`: Represents the active state during task or local workflow execution. This is where the `ExecutionParameters` object is held.
*   `serialization_settings`: Defines how Flyte entities are serialized.
*   `flyte_client`: An internal client for communicating with the Flyte backend.
*   `in_a_condition`: A flag indicating if the current context is within a conditional branch.
*   `output_metadata_tracker`: Tracks metadata related to outputs.
*   `worker_queue`: Manages worker processes for parallel execution.

### Building and Modifying Internal Context

Similar to `ExecutionParameters`, `FlyteContext` uses a `Builder` pattern to create new contexts with modified internal states. This is primarily used internally by the Flytekit library to manage nested contexts (e.g., during workflow compilation or conditional execution).

Methods like `with_execution_state()`, `with_compilation_state()`, and `enter_conditional_section()` are used by the system to create new context instances that reflect changes in the execution or compilation environment.

## Execution State

The `ExecutionState` object captures the specific environment and behavior during the execution of a task or a local workflow. It is a critical component of the `FlyteContext` and directly influences how tasks behave.

### Execution Modes

The `ExecutionState` defines various `Mode` values that dictate how tasks are executed:

*   `TASK_EXECUTION`: The mode used when a task executes in a production-like runtime environment (e.g., within a container managed by the Flyte engine). For dynamic tasks, this mode triggers the extraction of a runtime specification.
*   `LOCAL_WORKFLOW_EXECUTION`: The mode used when a workflow is executed locally. In this mode, tasks are not run directly as user-defined functions; instead, their return values are wrapped in `NodeOutput` objects to simulate workflow graph execution.
*   `LOCAL_TASK_EXECUTION`: The mode for purely local task execution, without a container or the Flyte engine. This differs from `TASK_EXECUTION` as it runs the task's user function directly, without runtime environment considerations.
*   `DYNAMIC_TASK_EXECUTION`: Indicates that the current execution is within a dynamic task.
*   `EAGER_EXECUTION`: A mode for eager execution.
*   `EAGER_LOCAL_EXECUTION`: A mode for eager local execution.
*   `LOCAL_DYNAMIC_TASK_EXECUTION`: A mode for local dynamic task execution.

### Key Properties

*   `mode`: The current `ExecutionState.Mode` indicating the execution context.
*   `working_dir`: The remote or external directory where inputs, outputs, and protobufs are uploaded.
*   `engine_dir`: A local directory within `working_dir` for engine-specific artifacts.
*   `branch_eval_mode`: Used in conditional (if-else) blocks to determine if a branch should execute (`BRANCH_ACTIVE`) or be skipped (`BRANCH_SKIPPED`).
*   `user_space_params`: The `ExecutionParameters` object, providing the user-facing context for the current execution.

### State Manipulation

The `ExecutionState` provides methods to manage its internal state, particularly for conditional logic and creating modified states:

*   `take_branch()`: Sets `branch_eval_mode` to `BRANCH_ACTIVE`, indicating that the current conditional branch should be executed. This is primarily used in local execution.
*   `branch_complete()`: Sets `branch_eval_mode` to `BRANCH_SKIPPED`, indicating that the current conditional branch is complete or should be skipped.
*   `with_params(...)`: Creates a new `ExecutionState` instance, allowing specific parameters to be overridden while retaining others from the current state.
*   `is_local_execution()`: A utility method to check if the current mode corresponds to any local execution scenario.

## Interplay and Hierarchy

The three core components—`ExecutionParameters`, `FlyteContext`, and `ExecutionState`—work together to provide a comprehensive execution environment:

1.  **`FlyteContext`** is the top-level internal container, managing the overall state of the Flytekit library.
2.  **`FlyteContext`** holds an **`ExecutionState`** object, which defines the specific runtime environment (e.g., local execution, production task execution) and its associated directories and modes.
3.  **`ExecutionState`** in turn holds the **`ExecutionParameters`** object (`user_space_params`), which is the context exposed directly to user-defined task code.

This hierarchy ensures a clear separation of concerns: internal system logic operates on `FlyteContext` and `ExecutionState`, while user code interacts with the simplified and task-relevant `ExecutionParameters`. This design allows the system to manage complex execution flows (like conditional branches or dynamic tasks) while providing a consistent and intuitive interface for developers within their task functions.
<!--
key: summary_execution_context_&_state_management_84e7bac5-8317-4448-8e33-ae4ea57be726
type: summary_end

-->
<!--
code_unit: flytekit.core.context_manager.ExecutionParameters
code_unit_type: class
help_text: ''
key: example_0a8213a3-e86c-4a7a-8886-79c324a465d6
type: example

-->
<!--
code_unit: flytekit.core.context_manager.FlyteContext
code_unit_type: class
help_text: ''
key: example_0822beb8-5487-4c8a-82e9-ee78c87fc65c
type: example

-->
<!--
code_unit: flytekit.core.context_manager.ExecutionState
code_unit_type: class
help_text: ''
key: example_25df03a8-ef22-49e2-8fff-c7c998a5f437
type: example

-->